import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url || __dirname)
import {
  getObject
} from "./chunk-YXXB6QIT.js";

// ../../lib/fs/index.ts
import fs from "fs/promises";
var CHUNK_SIZE = 1024;
function createReadableStream(filename) {
  let fileHandle;
  let position = 0;
  return new ReadableStream({
    async start() {
      fileHandle = await fs.open(filename, "r");
    },
    async pull(controller) {
      const buffer = new Uint8Array(CHUNK_SIZE);
      const { bytesRead } = await fileHandle.read(buffer, 0, CHUNK_SIZE, position);
      if (bytesRead === 0) {
        await fileHandle.close();
        controller.close();
      } else {
        position += bytesRead;
        controller.enqueue(buffer.subarray(0, bytesRead));
      }
    },
    cancel() {
      return fileHandle.close();
    }
  });
}

// ../../lib/node-http/get-framework.ts
import http2 from "node:http";

// ../../lib/node-http/response.ts
import http from "node:http";
import { Readable } from "node:stream";
var headerEnd = "\r\n\r\n";
var BODY = Symbol();
var HEADERS = Symbol();
function getString(data) {
  if (Buffer.isBuffer(data)) {
    return data.toString("utf8");
  } else if (typeof data === "string") {
    return data;
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
function addData(stream2, data) {
  if (Buffer.isBuffer(data) || typeof data === "string" || data instanceof Uint8Array) {
    stream2.push(Buffer.from(data));
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
var ServerlessResponse = class extends http.ServerResponse {
  _header = "";
  _wroteHeader = false;
  constructor(request) {
    super(request);
    const body = new Readable({ read() {
    } });
    this[BODY] = body;
    this[HEADERS] = {};
    this.useChunkedEncodingByDefault = false;
    this.chunkedEncoding = false;
    this._header = "";
    this.assignSocket({
      _writableState: {},
      writable: true,
      // @ts-ignore
      on: Function.prototype,
      // @ts-ignore
      removeListener: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype,
      // @ts-ignore
      cork: Function.prototype,
      // @ts-ignore
      uncork: Function.prototype,
      // @ts-ignore
      write: (data, encoding, cb) => {
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = void 0;
        }
        if (this._header === "" || this._wroteHeader) {
          addData(body, data);
        } else {
          const string = getString(data);
          const index = string.indexOf(headerEnd);
          if (index !== -1) {
            const remainder = string.slice(index + headerEnd.length);
            addData(body, remainder);
            this._wroteHeader = true;
            this.emit("headers");
          }
        }
        if (typeof cb === "function") {
          cb();
        }
        return true;
      }
    });
    this.once("finish", () => {
      body.push(null);
      this.emit("close");
    });
  }
  static async headers(res) {
    await new Promise((resolve) => {
      if (res._wroteHeader) {
        resolve();
      } else {
        res.once("headers", resolve);
      }
    });
    const headers = typeof res.getHeaders === "function" ? res.getHeaders() : res._headers;
    return Object.assign(headers, res[HEADERS]);
  }
  static body(response) {
    return response[BODY];
  }
  // Express does some strange prototype rewriting, so you can't use instance methods to read the body
  get headers() {
    return this[HEADERS];
  }
  setHeader(key, value) {
    if (this._wroteHeader) {
      this[HEADERS][key] = value;
    } else {
      super.setHeader(key, value);
    }
    return this;
  }
  writeHead(statusCode, reason, obj) {
    if (reason || obj) {
      let headers = {};
      if (typeof reason === "string" && obj) {
        headers = obj;
      } else if (typeof reason === "object") {
        headers = reason;
      }
      for (const name in headers) {
        this.setHeader(name, headers[name]);
        if (!this._wroteHeader) {
          break;
        }
      }
    }
    super.writeHead(statusCode, reason, obj);
    return this;
  }
};

// ../../lib/node-http/get-framework.ts
function common(cb) {
  return (request) => {
    const response = new ServerlessResponse(request);
    cb(request, response);
    return response;
  };
}
function getFramework(app) {
  if (app instanceof http2.Server) {
    return (request) => {
      const response = new ServerlessResponse(request);
      app.emit("request", request, response);
      return response;
    };
  }
  if (typeof app.callback === "function") {
    return common(app.callback());
  }
  if (typeof app.handle === "function") {
    return common((request, response) => {
      app.handle(request, response);
    });
  }
  if (typeof app.handler === "function") {
    return common((request, response) => {
      app.handler(request, response);
    });
  }
  if (typeof app._onRequest === "function") {
    return common((request, response) => {
      app._onRequest(request, response);
    });
  }
  if (typeof app === "function") {
    return common(app);
  }
  if (app.router && typeof app.router.route == "function") {
    return common((req, res) => {
      const { url, method, headers } = req;
      app.router.route({ url, method, headers, body: req }, res);
    });
  }
  if (app._core && typeof app._core._dispatch === "function") {
    return common(
      app._core._dispatch({
        app
      })
    );
  }
  if (typeof app.ready === "function") {
    return async (request) => {
      const response = new ServerlessResponse(request);
      await app.ready();
      app.server.emit("request", request, response);
      return response;
    };
  }
  if (typeof app.main === "function") {
    return common(app.main);
  }
  throw new Error("Unsupported framework");
}

// ../../lib/node-http/request.ts
import http3 from "node:http";
var ServerlessRequest = class extends http3.IncomingMessage {
  // type dis
  requestContext;
  // type dis
  apiGateway;
  rawBody = Buffer.alloc(0);
  constructor({
    method,
    url,
    headers,
    body,
    remoteAddress
  }) {
    super({
      encrypted: true,
      readable: false,
      remoteAddress,
      address: () => ({ port: 443 }),
      // @ts-ignore
      end: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype
    });
    Object.assign(this, {
      ip: remoteAddress,
      complete: true,
      httpVersion: "1.1",
      httpVersionMajor: "1",
      httpVersionMinor: "1",
      method,
      headers,
      rawBody: Buffer.alloc(0),
      url
    });
    this._read = () => {
      if (!body) {
        this.push(null);
        return;
      }
      const chunk = body.read();
      this.push(chunk);
      if (chunk) {
        this.rawBody = Buffer.concat([this.rawBody, chunk]);
      }
    };
  }
};

// ../../lib/node-http/create-request.ts
function createRequest(request, context) {
  const httpHeaders = {};
  request.headers.forEach((value, key) => {
    httpHeaders[key] = value;
  });
  const url = new URL(request.url);
  return new ServerlessRequest({
    method: request.method,
    headers: httpHeaders,
    // @ts-ignore
    body: request.body,
    remoteAddress: context.remoteAddress,
    // IncomingMessage.url does not include the protocol and host
    url: `${url.pathname}${url.search}`
  });
}

// ../../lib/node-http/index.ts
function nodeAdapter(handler) {
  const getResponse = getFramework(handler);
  return async function(requestEvent, context) {
    const request = createRequest(requestEvent, context);
    const response = await getResponse(request);
    const nodeHeaders = await ServerlessResponse.headers(response);
    const headers = new Headers();
    const names = Object.keys(nodeHeaders);
    for (const name of names) {
      const value = nodeHeaders[name];
      if (value === void 0) {
        continue;
      }
      if (Array.isArray(value)) {
        for (const item of value) {
          headers.append(name, item);
        }
      } else {
        headers.set(name, value.toString());
      }
    }
    return new Response(ServerlessResponse.body(response), {
      headers,
      status: response.statusCode
    });
  };
}

// http/index.ts
import path from "node:path";
import stream from "node:stream";

// logging.ts
function applicationError(err, msg) {
  console.log(
    JSON.stringify({
      time: Date.now(),
      level: 50,
      msg,
      err: { message: err.message, stack: err.stack, code: err.code }
    }) + "\n"
  );
}

// http/index.ts
import assert from "node:assert";
var Handler = class {
  prefix;
  handler;
  constructor(prefix, handler) {
    this.prefix = prefix;
    this.handler = handler;
  }
};
function normalize(path2) {
  return path2.replace(/\/+/g, "/").replace(/^\//, "").replace(/\/$/, "");
}
async function getStaticAssetObject(relativePath) {
  assert(process.env.AMPT_ASSETS_LOCATION, "AMPT_ASSETS_LOCATION is not set");
  const s3url = `https://${process.env.STORAGE_BUCKET}.s3.${process.env.AWS_REGION}.amazonaws.com/static-assets/${path.posix.join(process.env.AMPT_ASSETS_LOCATION, relativePath)}`;
  const result = await getObject(s3url).catch(() => void 0);
  if (!result) {
    return void 0;
  }
  return result;
}
async function getS3AssetResponse(relativePath, statusCode) {
  const result = await getStaticAssetObject(relativePath);
  if (!result) {
    throw new Error("Invalid path in http.on()");
  }
  return new Response(result.body, {
    status: statusCode,
    headers: {
      ...result.etag && { etag: result.etag },
      ...result.contentType && { "content-type": result.contentType },
      ...result.cacheControl && { "cache-control": result.cacheControl }
    }
  });
}
var Http = class {
  useNode = false;
  loaders = [];
  listenerAdded = false;
  defaultNotFoundResponse = new Response("Not Found", { status: 404 });
  defaultErrorResponse = new Response("Internal Server Error", { status: 500 });
  parent;
  node;
  constructor(args) {
    this.useNode = args?.useNode || false;
    if (!this.useNode) {
      const nodeHttp = new Http({ useNode: true, parent: this });
      delete nodeHttp.node;
      this.node = nodeHttp;
    } else {
      this.parent = args?.parent;
    }
  }
  static parseUseArgs(prefixOrHandler, _handler) {
    const handler = _handler ? _handler : prefixOrHandler;
    const eventPrefix = _handler ? normalize(prefixOrHandler) : "";
    return {
      handler,
      eventPrefix
    };
  }
  use(prefixOrHandler, _handler) {
    const { handler, eventPrefix } = Http.parseUseArgs(prefixOrHandler, _handler);
    const handlerPrefix = `/${eventPrefix}`;
    const instance = this.parent || this;
    const patchedHandler = this.useNode ? nodeAdapter(handler) : handler;
    instance.loaders.push(new Handler(handlerPrefix, patchedHandler));
    instance.addListener();
  }
  addListener() {
    if (this.listenerAdded) {
      return;
    }
    addEventListener("fetch", (event, eventContext) => {
      event.respondWith(this.handleEvent(event, eventContext));
    });
    this.listenerAdded = true;
  }
  // keep the original handler for compatibility with prev. versions
  useNodeHandler(prefixOrHandler, _handler) {
    if (!this.useNode && this.node) {
      this.node?.use(prefixOrHandler, _handler);
    } else {
      this.use(prefixOrHandler, _handler);
    }
  }
  async handleEvent(event, context) {
    const notFoundResponses = [];
    const url = new URL(event.request.url);
    try {
      for (const loader of this.loaders) {
        if (!url.pathname.startsWith(loader.prefix)) {
          continue;
        }
        const result = loader.handler(event.request, context);
        if (!result) {
          continue;
        }
        const response = await result;
        if (!response) {
          continue;
        }
        if (response.status !== 404) {
          return response;
        }
        notFoundResponses.push(response);
      }
      return notFoundResponses.shift() || await this.defaultNotFoundResponse;
    } catch (err) {
      applicationError(err, "HTTP handler failed");
      return await this.defaultErrorResponse;
    }
  }
  on(eventName, relativePath) {
    if (this.useNode) {
      throw new Error("Http.on() is not supported in node mode");
    }
    if (eventName.toString() === "404") {
      if (relativePath.startsWith("static/") && process.env.AMPT_ASSETS_LOCATION) {
        this.defaultNotFoundResponse = getS3AssetResponse(relativePath.slice(7), 404);
      } else {
        this.defaultNotFoundResponse = new Response(createReadableStream(relativePath), {
          status: 404,
          headers: {
            "Content-Type": "text/html",
            "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
          }
        });
      }
    } else if (eventName.toString() === "500") {
      if (relativePath.startsWith("static/") && process.env.AMPT_ASSETS_LOCATION) {
        this.defaultErrorResponse = getS3AssetResponse(relativePath.slice(7), 500);
      } else {
        this.defaultErrorResponse = new Response(createReadableStream(relativePath), {
          status: 500,
          headers: {
            "Content-Type": "text/html",
            "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
          }
        });
      }
    } else {
      throw new Error(`Unsupported event name for http.on(): ${eventName}`);
    }
    this.addListener();
  }
  async readStaticFile(relativePath) {
    let result;
    if (process.env.AMPT_ASSETS_LOCATION) {
      result = (await getStaticAssetObject(relativePath))?.body;
    } else {
      result = createReadableStream(path.join("static", relativePath));
    }
    if (this.useNode) {
      if (result && result instanceof ReadableStream) {
        const nodeStream = stream.Readable.fromWeb(result);
        return nodeStream;
      } else {
        return result;
      }
    } else {
      return result;
    }
  }
};
var http4 = new Http();

export {
  normalize,
  Http,
  http4 as http
};
